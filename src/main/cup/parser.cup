package com.clysman.compiler;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

parser code {:
    public Map<String, SymbolInfo> symbolTable = new HashMap<>();

    private scanner scanner;

    public parser(scanner scanner) {
        this.scanner = scanner;
    }

    public enum ErrorType {
        SEMANTICAL("SemanticalError"),
        TYPE("TypeError"),
        SYNTAX("SyntaxError");

        private final String description;

        ErrorType(String description) {
            this.description = description;
        }

        public String getDescription() {
            return description;
        }
    }

    public void syntax_error(Symbol cur_token) {
        fatal_error(ErrorType.SYNTAX, "Token inesperado '" + cur_token.value + "'");
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        fatal_error(ErrorType.SYNTAX, "Erro de sintaxe não recuperável. Compilação interrompida.");
    }

    private void fatal_error(ErrorType errorType, String message, int line, int column) {
        System.err.println("[" + errorType.getDescription() + " - Linha " + line +
                          ", Coluna " + column + "] " + message);
        System.exit(1);
    }

    private void fatal_error(ErrorType errorType, String message) {
        System.err.println("["+ errorType.getDescription() + "] " + message);
        System.exit(1);
    }

    public class SymbolInfo {
        public String name;
        public Object type;

        public SymbolInfo(String name, Object type) {
            this.name = name;
            this.type = type;
        }
    }

    class ExprResult {
        public Object type;
        public String representation;

        ExprResult(String type, String representation) {
            this.type = type;
            this.representation = representation;
        }

        public String toString() {
            return this.representation;
        }
    }
:}

scan with {: return scanner.next_token(); :};

terminal IF, ELSE, WHILE, FOR, RETURN;
terminal INT_TYPE, FLOAT_TYPE, BOOL_TYPE, STRING_TYPE, VOID;
terminal TRUE, FALSE;
terminal FUNCTION;
terminal BREAK, CONTINUE;

terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal EQ, NE, LT, LE, GT, GE;
terminal AND, OR, NOT;
terminal ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIVIDE_ASSIGN;

terminal SEMICOLON, COMMA;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;

terminal String IDENTIFIER;
terminal Integer INT_LITERAL;
terminal Double FLOAT_LITERAL;
terminal String STRING_LITERAL;

// Não-terminais
non terminal program;
non terminal statement_list;
non terminal statement;
non terminal declaration;
non terminal assignment;
non terminal if_statement;
non terminal while_statement;
non terminal for_statement;
non terminal return_statement;
non terminal block;
non terminal expression;
non terminal logical_or_expr;
non terminal logical_and_expr;
non terminal equality_expr;
non terminal relational_expr;
non terminal additive_expr;
non terminal multiplicative_expr;
non terminal unary_expr;
non terminal primary_expr;
non terminal type;

// Precedência dos operadores
precedence left OR;
precedence left AND;
precedence left EQ, NE;
precedence left LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right NOT;

statement_list ::= statement_list:sl statement:s
    | statement:s
;

statement ::= declaration:d
    | assignment:a
    | if_statement:i
    | while_statement:w
    | for_statement:f
    | return_statement:r
;

declaration ::= type:t IDENTIFIER:id SEMICOLON
        {:
            if (symbolTable.containsKey(id)) {
                fatal_error(ErrorType.SEMANTICAL, "Variável '" + id + "' já foi declarada.");
            } else {
                symbolTable.put(id, new SymbolInfo(id, t));
            }
        :}
    | type:t IDENTIFIER:id ASSIGN expression:e SEMICOLON
        {:
            if (symbolTable.containsKey(id)) {
                fatal_error(ErrorType.SEMANTICAL, "Variável '" + id + "' já foi declarada.");
            } else {
                ExprResult expr = (ExprResult) e;

                if (!expr.type.equals(t)) {
                    fatal_error(ErrorType.TYPE, "Esperado tipo '" + t + "', mas encontrado '" + expr.type + "'.");
                }

                symbolTable.put(id, new SymbolInfo(id, t));
            }
        :}
;

assignment ::= IDENTIFIER:id ASSIGN expression:e SEMICOLON
        {:
            SymbolInfo info = symbolTable.get(id);
            ExprResult expr = (ExprResult) e;

            if (info == null) {
                fatal_error(ErrorType.SEMANTICAL, "Variável '" + id + "' não declarada.");
            } else if (!info.type.equals(expr.type)) {
                fatal_error(ErrorType.TYPE, "Esperado '" + info.type + "', encontrado '" + expr.type + "'");
            }
        :}
    | IDENTIFIER:id PLUS_ASSIGN expression:e SEMICOLON
        {:
            SymbolInfo info = symbolTable.get(id);
            ExprResult expr = (ExprResult) e;

            if (info == null) {
                fatal_error(ErrorType.SEMANTICAL, "Variável '" + id + "' não declarada.");
            } else if (!expr.type.equals("number")) {
                fatal_error(ErrorType.TYPE, "Esperado 'number', encontrado '" + expr.type + "'");
            }
        :}
    | IDENTIFIER:id MINUS_ASSIGN expression:e SEMICOLON
        {:
            SymbolInfo info = symbolTable.get(id);
            ExprResult expr = (ExprResult) e;

            if (info == null) {
                fatal_error(ErrorType.SEMANTICAL, "Variável '" + id + "' não declarada.");
            } else if (!expr.type.equals("number")) {
                fatal_error(ErrorType.TYPE, "Esperado 'number', encontrado '" + expr.type + "'");
            }
        :}
    | IDENTIFIER:id TIMES_ASSIGN expression:e SEMICOLON
        {:
            SymbolInfo info = symbolTable.get(id);
            ExprResult expr = (ExprResult) e;

            if (info == null) {
                fatal_error(ErrorType.SEMANTICAL, "Variável '" + id + "' não declarada.");
            } else if (!expr.type.equals("number")) {
                fatal_error(ErrorType.TYPE, "Esperado 'number', encontrado '" + expr.type + "'");
            }
        :}
    | IDENTIFIER:id DIVIDE_ASSIGN expression:e SEMICOLON
        {:
            SymbolInfo info = symbolTable.get(id);
            ExprResult expr = (ExprResult) e;

            if (info == null) {
                fatal_error(ErrorType.SEMANTICAL, "Variável '" + id + "' não declarada.");
            } else if (!expr.type.equals("number")) {
                fatal_error(ErrorType.TYPE, "Esperado 'number', encontrado '" + expr.type + "'");
            }
        :}
;

if_statement ::= IF LPAREN expression:e RPAREN block:b
        {:
            ExprResult expr = (ExprResult) e;
            if (!expr.type.equals("bool")) {
                fatal_error(ErrorType.TYPE, "Esperado 'bool', encontrado '" + expr.type + "'");
            }
        :}
    | IF LPAREN expression:e RPAREN block:b ELSE block:eb
        {:
            ExprResult expr = (ExprResult) e;
            if (!expr.type.equals("bool")) {
                fatal_error(ErrorType.TYPE, "Esperado 'bool', encontrado '" + expr.type + "'");
            }
        :}
    | IF LPAREN expression:e RPAREN block:b ELSE if_statement:ei
        {:
            ExprResult expr = (ExprResult) e;
            if (!expr.type.equals("bool")) {
                fatal_error(ErrorType.TYPE, "Esperado 'bool', encontrado '" + expr.type + "'");
            }
        :}
;

while_statement ::= WHILE LPAREN expression:e RPAREN statement:s
        {:
            ExprResult expr = (ExprResult) e;
            if (!expr.type.equals("bool")) {
                fatal_error(ErrorType.TYPE, "Esperado 'bool', encontrado '" + expr.type + "'");
            }
        :}
;

for_statement ::= FOR LPAREN assignment:e expression:cond SEMICOLON assignment:update RPAREN statement:s
        {:
            ExprResult expr = (ExprResult) cond;
            if (!expr.type.equals("bool")) {
                fatal_error(ErrorType.TYPE, "Esperado 'bool', encontrado '" + expr.type + "'");
            }
        :}
;

return_statement ::= RETURN SEMICOLON
    | RETURN expression:e SEMICOLON
;

block ::= LBRACE statement_list:sl RBRACE
;

expression ::= logical_or_expr:e
    {: RESULT = e; :}
;

logical_or_expr ::= logical_or_expr:e1 OR logical_and_expr:e2
        {:
            ExprResult expr1 = (ExprResult) e1;
            ExprResult expr2 = (ExprResult) e2;
            if (!expr1.type.equals("bool") || !expr2.type.equals("bool")) {
                fatal_error(ErrorType.TYPE, "Operador '||' requer operandos do tipo 'bool'.");
            }

            RESULT = new ExprResult("bool", e1 + " || " + e2);
        :}
    | logical_and_expr:e
        {: RESULT = e; :}
;


logical_and_expr ::= logical_and_expr:e1 AND equality_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("bool") || !expr2.type.equals("bool")) {
            fatal_error(ErrorType.TYPE, "Operador '&&' requer operandos do tipo 'bool'.");
        }
        RESULT = new ExprResult("bool", e1 + " && " + e2);
    :}
  | equality_expr:e
    {: RESULT = e; :}
;

equality_expr ::= equality_expr:e1 EQ relational_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals(expr2.type)) {
            fatal_error(ErrorType.TYPE, "Comparação '==' entre tipos incompatíveis ('" + expr1.type + "' e '" + expr2.type + "').");
        }
        RESULT = new ExprResult("bool", e1 + " == " + e2);
    :}
  | equality_expr:e1 NE relational_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals(expr2.type)) {
            fatal_error(ErrorType.TYPE, "Comparação '!=' entre tipos incompatíveis ('" + expr1.type + "' e '" + expr2.type + "').");
        }
        RESULT = new ExprResult("bool", e1 + " != " + e2);
    :}
  | relational_expr:e
    {: RESULT = e; :}
;

relational_expr ::= relational_expr:e1 LT additive_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '<' requer operandos numéricos.");
        }
        RESULT = new ExprResult("bool", e1 + " < " + e2);
    :}
  | relational_expr:e1 LE additive_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '<=' requer operandos numéricos.");
        }
        RESULT = new ExprResult("bool", e1 + " <= " + e2);
    :}
  | relational_expr:e1 GT additive_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '>' requer operandos numéricos.");
        }
        RESULT = new ExprResult("bool", e1 + " > " + e2);
    :}
  | relational_expr:e1 GE additive_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '>=' requer operandos numéricos.");
        }
        RESULT = new ExprResult("bool", e1 + " >= " + e2);
    :}
  | additive_expr:e
    {: RESULT = e; :}
;

additive_expr ::= additive_expr:e1 PLUS multiplicative_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '+' requer operandos numéricos.");
        }
        RESULT = new ExprResult("number", e1 + " + " + e2);
    :}
  | additive_expr:e1 MINUS multiplicative_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '-' requer operandos numéricos.");
        }
        RESULT = new ExprResult("number", e1 + " - " + e2);
    :}
  | multiplicative_expr:e
    {: RESULT = e; :}
;

multiplicative_expr ::= multiplicative_expr:e1 TIMES unary_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '*' requer operandos numéricos.");
        }
        RESULT = new ExprResult("number", e1 + " * " + e2);
    :}
  | multiplicative_expr:e1 DIVIDE unary_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '/' requer operandos numéricos.");
        }
        RESULT = new ExprResult("number", e1 + " / " + e2);
    :}
  | multiplicative_expr:e1 MOD unary_expr:e2
    {:
        ExprResult expr1 = (ExprResult) e1;
        ExprResult expr2 = (ExprResult) e2;
        if (!expr1.type.equals("number") || !expr2.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '%' requer operandos numéricos.");
        }
        RESULT = new ExprResult("number", e1 + " % " + e2);
    :}
  | unary_expr:e
    {: RESULT = e; :}
;

unary_expr ::= NOT unary_expr:e
    {:
        ExprResult expr = (ExprResult) e;
        if (!expr.type.equals("bool")) {
            fatal_error(ErrorType.TYPE, "Operador '!' requer operando do tipo 'bool'.");
        }
        RESULT = new ExprResult("bool", "!" + e);
    :}
    | MINUS unary_expr:e
    {:
        ExprResult expr = (ExprResult) e;
        if (!expr.type.equals("number")) {
            fatal_error(ErrorType.TYPE, "Operador '-' unário requer operando numérico.");
        }
        RESULT = new ExprResult("number", "-" + e);
    :}
    | primary_expr:e                {: RESULT = e; :}
;

primary_expr ::= STRING_LITERAL:s   {: RESULT = new ExprResult("string", "\"" + s + "\""); :}
    | INT_LITERAL:i                 {: RESULT = new ExprResult("number", i.toString()); :}
    | FLOAT_LITERAL:f               {: RESULT = new ExprResult("number", f.toString()); :}
    | TRUE                          {: RESULT = new ExprResult("bool", "true"); :}
    | FALSE                         {: RESULT = new ExprResult("bool", "false"); :}
    | IDENTIFIER:id
        {:
            SymbolInfo info = symbolTable.get(id);

            if (info == null) {
                fatal_error(ErrorType.SEMANTICAL, "Variável '" + id + "' não declarada.");
            }

            RESULT = new ExprResult((String) info.type, id);
        :}
    | LPAREN expression:e RPAREN    {: RESULT = new ExprResult((String) ((ExprResult) e).type, "(" + e + ")"); :}
;

type ::= INT_TYPE     {: RESULT = "number"; :}
       | FLOAT_TYPE   {: RESULT = "number"; :}
       | BOOL_TYPE    {: RESULT = "bool"; :}
       | STRING_TYPE  {: RESULT = "string"; :}
       | VOID         {: RESULT = "void"; :}
;